---
interface Props {
  chartData: any;
  title?: string;
  id: string;
}

const { chartData, title, id } = Astro.props;
---

<div 
  class="plotly-chart-wrapper my-8" 
  data-chart={JSON.stringify(chartData)}
>
  {title && <h3 class="text-xl font-bold mb-4">{title}</h3>}
  {chartData && !chartData.error ? (
    <div id={id} class="plotly-graph-div w-full min-h-[500px] h-[500px]"></div>
  ) : (
    <div class="flex items-center justify-center min-h-[100px] bg-skin-fill/30 border border-dashed border-skin-line rounded-lg">
      <p class="text-gray-500 italic">{chartData?.error || 'データが利用できません'}</p>
    </div>
  )}
</div>

<script>
  declare const Plotly: any;

  function initPlotlyCharts() {
    const wrappers = document.querySelectorAll('.plotly-chart-wrapper');
    
    wrappers.forEach(wrapper => {
      const container = wrapper.querySelector('.plotly-graph-div') as HTMLElement;
      if (!container || (container as any)._plotly_initialized) return;

      const chartDataStr = (wrapper as HTMLElement).dataset.chart;
      if (!chartDataStr) return;

      const chartData = JSON.parse(chartDataStr);
      if (!chartData || chartData.error) return;

      // IntersectionObserver で画面に近づいたときに描画
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            observer.disconnect();
            
            // ResizeObserver でコンテナの高さが確定するのを待つ (Astro View Transitions 対策)
            const ro = new ResizeObserver(() => {
              if (container.clientHeight > 100) {
                ro.disconnect();
                requestAnimationFrame(() => {
                  renderChart(container, chartData);
                  (container as any)._plotly_initialized = true;
                });
              }
            });
            ro.observe(container);
          }
        });
      }, { rootMargin: '200px' });
      
      observer.observe(container);
    });
  }

  function renderChart(container: HTMLElement, chartData: any) {
    if (typeof Plotly === 'undefined') return;

    const isDark = document.documentElement.classList.contains('dark') || 
                   document.documentElement.getAttribute('data-theme') === 'dark';
    const isMobile = window.innerWidth < 768;
    
    // データ側のレイアウトを尊重しつつ、テーマとサイズのみ同期
    const layout = JSON.parse(JSON.stringify(chartData.layout || {}));
    
    // テンプレートを復活させる（全体のデザインを整えるため）
    layout.template = isDark ? 'plotly_dark' : 'plotly_white';

    // サイトのテーマカラーを定義
    const accentColor = isDark ? '#ff6b01' : '#006cac'; // オレンジ / 青
    const inactiveBg = isDark ? '#374151' : '#9ca3af';  // 濃いグレー / 灰色

    // updatemenus（切り替えボタン）の設定
    if (layout.updatemenus && layout.updatemenus.length > 0) {
      layout.updatemenus.forEach((menu: any) => {
        menu.font = { color: '#ffffff', size: isMobile ? 11 : 13 };
        menu.bgcolor = inactiveBg;
        menu.activecolor = accentColor;
        menu.bordercolor = isDark ? accentColor : 'transparent';
        menu.borderwidth = isDark ? 1 : 0;
        menu.showactive = true;
        
        if (isMobile) {
          menu.type = "dropdown";
          menu.direction = "down";
          menu.x = 0.5;
          menu.xanchor = "center";
          menu.y = 1.2; 
        }
      });
    }

    // 全体の背景を透過
    layout.paper_bgcolor = 'rgba(0,0,0,0)';
    layout.plot_bgcolor = 'rgba(0,0,0,0)';
    
    if (isMobile) {
      layout.margin = { t: 100, r: 10, b: 100, l: 50 };
    } else {
      layout.margin = { t: 50, r: 30, b: 50, l: 60 };
    }
    
    layout.dragmode = false; 

    // 軸の設定（テンプレートの上から微調整）
    const grey = isDark ? '#9ca3af' : 'rgba(0, 0, 0, 0.6)';
    const gridColor = isDark ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';
    
    const updateAxis = (axisName: string) => {
      if (!layout[axisName]) layout[axisName] = {};
      layout[axisName].gridcolor = gridColor;
      layout[axisName].tickfont = { color: grey };
      if (axisName === 'xaxis' && isMobile) {
        layout[axisName].tickangle = 45;
        layout[axisName].nticks = 5;
      }
    };
    ['xaxis', 'yaxis', 'yaxis2'].forEach(updateAxis);

    // 以前のオブザーバーがあれば停止（クリーンアップ）
    if ((container as any)._custom_observer) {
      (container as any)._custom_observer.disconnect();
    }

    // 以前の状態を完全にクリアしてから描画
    Plotly.purge(container);
    Plotly.newPlot(container, chartData.data, layout, {
      displayModeBar: false,
      responsive: true,
      scrollZoom: false,
      staticPlot: false,
      showTips: false,
    }).then(() => {
      // 選択中のタブを強制的にアクセントカラーにする関数
      const fixActiveTab = () => {
        // 現在のレイアウト状態から最新のアクティブインデックスを取得
        const currentLayout = (container as any).layout;
        if (!currentLayout || !currentLayout.updatemenus) return;

        // テーマの最新状態を再確認
        const currentIsDark = document.documentElement.classList.contains('dark') || 
                              document.documentElement.getAttribute('data-theme') === 'dark';
        const currentAccent = currentIsDark ? '#ff6b01' : '#006cac';
        const currentInactive = currentIsDark ? '#374151' : '#9ca3af';

        const menuContainers = container.querySelectorAll('.updatemenu-container');
        
        currentLayout.updatemenus.forEach((menu: any, menuIdx: number) => {
          const activeIdx = menu.active || 0;
          const currentMenuContainer = menuContainers[menuIdx];
          
          if (currentMenuContainer) {
            const rects = currentMenuContainer.querySelectorAll('.updatemenu-item-rect');
            const texts = currentMenuContainer.querySelectorAll('.updatemenu-item-text');
            
            rects.forEach((rect: any, i: number) => {
              const isSelected = i === activeIdx;
              const targetColor = isSelected ? currentAccent : currentInactive;
              
              // Plotlyのデフォルト上書きを防ぐため、属性とスタイルの両方を設定
              rect.setAttribute('fill', targetColor);
              rect.style.setProperty('fill', targetColor, 'important');
              
              // デイモードで枠を消す
              if (!currentIsDark) {
                rect.setAttribute('stroke-width', '0');
                rect.style.setProperty('stroke-width', '0', 'important');
              } else {
                rect.setAttribute('stroke', currentAccent);
                rect.setAttribute('stroke-width', '1');
                rect.style.setProperty('stroke', currentAccent, 'important');
                rect.style.setProperty('stroke-width', '1', 'important');
              }
              
              if (texts[i]) {
                (texts[i] as HTMLElement).setAttribute('fill', '#ffffff');
                (texts[i] as HTMLElement).style.setProperty('fill', '#ffffff', 'important');
              }
            });
          }
        });
      };

      // 1. 初回実行
      fixActiveTab();

      // 2. Plotlyのイベントで再適用（主要な更新タイミング）
      (container as any).on('plotly_afterplot', fixActiveTab);
      (container as any).on('plotly_restyle', fixActiveTab);
      (container as any).on('plotly_relayout', fixActiveTab);
      (container as any).on('plotly_click', fixActiveTab);

      // 3. MutationObserverでDOMの変更を「賢く」監視
      // 無限ループを防ぐため、自分で変更する間は監視を一時停止する
      const observer = new MutationObserver(() => {
        observer.disconnect(); // 監視を一時停止
        fixActiveTab();        // スタイル適用
        startObserving();      // 監視を再開
      });

      const startObserving = () => {
        observer.observe(container, { 
          childList: true, 
          subtree: true, 
          attributes: true, 
          attributeFilter: ['fill', 'style'] 
        });
      };

      startObserving();

      // ページ遷移時にタイマーやオブザーバーを掃除できるように参照を保存
      (container as any)._custom_observer = observer;

      // 描画直後と、アニメーション終了後の2段階でリサイズ
      requestAnimationFrame(() => {
        if (container && container.isConnected && (container as HTMLElement).offsetParent !== null) {
          Plotly.Plots.resize(container);
        }
        setTimeout(() => {
          if (container && container.isConnected && (container as HTMLElement).offsetParent !== null) {
            Plotly.Plots.resize(container);
          }
        }, 500);
      });
    });
  }

  // ページロードおよび遷移時に実行
  document.addEventListener('astro:page-load', () => {
    document.querySelectorAll('.plotly-graph-div').forEach(el => {
      (el as any)._plotly_initialized = false;
    });
    initPlotlyCharts();
  });

  // テーマ変更時に再描画
  const themeObserver = new MutationObserver(() => {
    document.querySelectorAll('.plotly-graph-div').forEach(container => {
      const wrapper = container.closest('.plotly-chart-wrapper') as HTMLElement;
      if (wrapper && (container as any)._plotly_initialized && container.isConnected && (container as HTMLElement).offsetParent !== null) {
        const chartData = JSON.parse(wrapper.dataset.chart || '{}');
        renderChart(container as HTMLElement, chartData);
      }
    });
  });
  themeObserver.observe(document.documentElement, { attributes: true });

  // リサイズ対応
  window.addEventListener('resize', () => {
    document.querySelectorAll('.plotly-graph-div').forEach(container => {
      if ((container as any)._plotly_initialized && container.isConnected && (container as HTMLElement).offsetParent !== null) {
        Plotly.Plots.resize(container);
      }
    });
  });
</script>

<style is:global>
  .plotly-graph-div {
    width: 100%;
    height: 500px !important;
    min-height: 400px !important; /* モバイル対応 */
    overflow: visible !important;
    touch-action: pan-y; /* グラフ上での縦スクロールを許可 */
  }
  @media (max-width: 768px) {
    .plotly-graph-div {
      height: 400px !important;
      min-height: 400px !important;
    }
  }
</style>
