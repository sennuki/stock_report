---
interface Props {
  chartData: any;
  title?: string;
  id: string;
}

const { chartData, title, id } = Astro.props;
---

<div 
  class="plotly-chart-wrapper my-8" 
  data-chart={JSON.stringify(chartData)}
>
  {title && <h3 class="text-xl font-bold mb-4">{title}</h3>}
  {chartData && !chartData.error ? (
    <div id={id} class="plotly-graph-div w-full min-h-[500px] h-[500px]"></div>
  ) : (
    <div class="flex items-center justify-center min-h-[100px] bg-skin-fill/30 border border-dashed border-skin-line rounded-lg">
      <p class="text-gray-500 italic">{chartData?.error || 'データが利用できません'}</p>
    </div>
  )}
</div>

<script>
  declare const Plotly: any;

  function initPlotlyCharts() {
    const wrappers = document.querySelectorAll('.plotly-chart-wrapper');
    
    wrappers.forEach(wrapper => {
      const container = wrapper.querySelector('.plotly-graph-div') as HTMLElement;
      if (!container || (container as any)._plotly_initialized) return;

      const chartDataStr = (wrapper as HTMLElement).dataset.chart;
      if (!chartDataStr) return;

      const chartData = JSON.parse(chartDataStr);
      if (!chartData || chartData.error) return;

      // IntersectionObserver で画面に近づいたときに描画
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            observer.disconnect();
            
            // ResizeObserver でコンテナの高さが確定するのを待つ (Astro View Transitions 対策)
            const ro = new ResizeObserver(() => {
              if (container.clientHeight > 100) {
                ro.disconnect();
                requestAnimationFrame(() => {
                  renderChart(container, chartData);
                  (container as any)._plotly_initialized = true;
                });
              }
            });
            ro.observe(container);
          }
        });
      }, { rootMargin: '200px' });
      
      observer.observe(container);
    });
  }

  function renderChart(container: HTMLElement, chartData: any) {
    if (typeof Plotly === 'undefined') return;

    const isDark = document.documentElement.classList.contains('dark') || 
                   document.documentElement.getAttribute('data-theme') === 'dark';
    const isMobile = window.innerWidth < 768;
    
    // データ側のレイアウトを尊重しつつ、テーマとサイズのみ同期
    const layout = JSON.parse(JSON.stringify(chartData.layout || {}));
    
    // updatemenus（切り替えボタン）が存在する場合、そのスタイルを調整
    if (layout.updatemenus && layout.updatemenus.length > 0) {
      layout.updatemenus.forEach((menu: any) => {
        if (!menu.font) menu.font = {};
        // 全てのボタンの文字色を「ほぼ黒」に統一（Plotlyの制限により選択・非選択で色を分けられないため）
        menu.font.color = isDark ? '#1a1a1a' : (menu.font.color || '#333333');
        // 背景色を明るくして、黒い文字とのコントラストを確保（ダークモードでもボタンが浮き上がって見えるように）
        if (!menu.bgcolor) menu.bgcolor = isDark ? 'rgba(200, 200, 200, 0.8)' : 'rgba(235, 235, 235, 0.9)';
        // 選択中のボタンは真っ白にして、強調する
        if (!menu.activecolor) menu.activecolor = isDark ? 'rgba(255, 255, 255, 1.0)' : 'rgba(255, 255, 255, 1.0)';
        if (!menu.bordercolor) menu.bordercolor = isDark ? 'rgba(0, 0, 0, 0.1)' : 'rgba(0, 0, 0, 0.1)';
      });
    }

    layout.template = isDark ? 'plotly_dark' : 'plotly_white';
    layout.paper_bgcolor = 'rgba(0,0,0,0)';
    layout.plot_bgcolor = 'rgba(0,0,0,0)';
    layout.height = isMobile ? 400 : 500;
    layout.autosize = true; // 横幅いっぱいに広げる
    // モバイル時はラベルが傾くため、下の余白を大幅に増やす (40 -> 100)
    layout.margin = isMobile ? { t: 40, r: 10, b: 100, l: 50 } : { t: 50, r: 30, b: 50, l: 60 };
    
    // モバイルでの誤動作（意図しないズームやスクロールの妨げ）を防ぐ
    layout.dragmode = false; 

    // 軸やフォントの色のみ微調整
    const grey = isDark ? '#9ca3af' : 'rgba(0, 0, 0, 0.6)';
    const gridColor = isDark ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';
    
    const updateAxis = (axisName: string) => {
      if (!layout[axisName]) layout[axisName] = {};
      layout[axisName].gridcolor = gridColor;
      layout[axisName].automargin = true;
      if (!layout[axisName].tickfont) layout[axisName].tickfont = {};
      layout[axisName].tickfont.color = grey;
      
      // モバイル時のラベル重なり対策 (特に貸借対照表などの日付)
      if (axisName === 'xaxis' && isMobile) {
        layout[axisName].tickangle = 45; // ラベルを斜めにする
        layout[axisName].nticks = 5;      // ラベルの数を間引く
      }

      if (layout[axisName].title && typeof layout[axisName].title !== 'string') {
        if (!layout[axisName].title.font) layout[axisName].title.font = {};
        layout[axisName].title.font.color = grey;
      }
    };
    ['xaxis', 'yaxis', 'yaxis2'].forEach(updateAxis);

    // レジェンドのスタイルと位置を調整
    if (!layout.legend) layout.legend = {};
    if (!layout.legend.font) layout.legend.font = {};
    layout.legend.font.color = grey;
    
    // モバイル時は凡例をさらに下に配置して重なりを防ぐ
    if (isMobile) {
      layout.legend.y = -0.4; 
      layout.legend.yanchor = 'top';
    }

    // 以前の状態を完全にクリアしてから描画
    Plotly.purge(container);
    Plotly.newPlot(container, chartData.data, layout, {
      displayModeBar: false,
      responsive: true,
      scrollZoom: false,
      staticPlot: false,
      doubleClick: false, // モバイルでのダブルタップズームを防ぐ
      showTips: false,
    }).then(() => {
      // 描画直後と、アニメーション終了後の2段階でリサイズ
      requestAnimationFrame(() => {
        if (container && container.isConnected && (container as HTMLElement).offsetParent !== null) {
          Plotly.Plots.resize(container);
        }
        setTimeout(() => {
          if (container && container.isConnected && (container as HTMLElement).offsetParent !== null) {
            Plotly.Plots.resize(container);
          }
        }, 500);
      });
    });
  }

  // ページロードおよび遷移時に実行
  document.addEventListener('astro:page-load', () => {
    document.querySelectorAll('.plotly-graph-div').forEach(el => {
      (el as any)._plotly_initialized = false;
    });
    initPlotlyCharts();
  });

  // テーマ変更時に再描画
  const themeObserver = new MutationObserver(() => {
    document.querySelectorAll('.plotly-graph-div').forEach(container => {
      const wrapper = container.closest('.plotly-chart-wrapper') as HTMLElement;
      if (wrapper && (container as any)._plotly_initialized && container.isConnected && (container as HTMLElement).offsetParent !== null) {
        const chartData = JSON.parse(wrapper.dataset.chart || '{}');
        renderChart(container as HTMLElement, chartData);
      }
    });
  });
  themeObserver.observe(document.documentElement, { attributes: true });

  // リサイズ対応
  window.addEventListener('resize', () => {
    document.querySelectorAll('.plotly-graph-div').forEach(container => {
      if ((container as any)._plotly_initialized && container.isConnected && (container as HTMLElement).offsetParent !== null) {
        Plotly.Plots.resize(container);
      }
    });
  });
</script>

<style is:global>
  .plotly-graph-div {
    width: 100%;
    height: 500px !important;
    min-height: 400px !important; /* モバイル対応 */
    overflow: visible !important;
    touch-action: pan-y; /* グラフ上での縦スクロールを許可 */
  }
  @media (max-width: 768px) {
    .plotly-graph-div {
      height: 400px !important;
      min-height: 400px !important;
    }
  }
</style>
