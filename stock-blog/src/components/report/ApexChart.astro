---
interface Props {
  chartData: any;
  title?: string;
  id: string;
  height?: number;
}

const { chartData, title, id, height = 450 } = Astro.props;
---

<div 
  class="apex-chart-wrapper my-8" 
  data-chart={JSON.stringify(chartData)}
  data-id={id}
>
  <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-4 gap-4">
    {title && <h3 class="text-xl font-bold text-skin-base">{title}</h3>}
    <div class="chart-controls flex gap-2"></div>
  </div>

  {chartData && !chartData.error ? (
    <div id={id} class="apex-graph-div w-full" style={`min-height: ${height}px;`}></div>
  ) : (
    <div class="flex items-center justify-center min-h-[100px] bg-skin-fill/30 border border-dashed border-skin-line rounded-lg">
      <p class="text-gray-500 italic">{chartData?.error || 'データが利用できません'}</p>
    </div>
  )}
</div>

<script>
  import ApexCharts from 'apexcharts';

  function initApexCharts() {
    const wrappers = document.querySelectorAll('.apex-chart-wrapper');
    
    wrappers.forEach(wrapper => {
      const container = wrapper.querySelector('.apex-graph-div') as HTMLElement;
      if (!container || (container as any)._apex_initialized) return;

      const chartDataStr = (wrapper as HTMLElement).dataset.chart;
      if (!chartDataStr) return;

      const chartData = JSON.parse(chartDataStr);
      if (!chartData || chartData.error) return;

      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            observer.disconnect();
            renderApexChart(wrapper as HTMLElement, container, chartData);
            (container as any)._apex_initialized = true;
          }
        });
      }, { rootMargin: '200px' });
      
      observer.observe(container);
    });
  }

  function renderApexChart(wrapper: HTMLElement, container: HTMLElement, plotlyData: any) {
    const isDark = document.documentElement.classList.contains('dark') || 
                   document.documentElement.getAttribute('data-theme') === 'dark';
    
    try {
      const options = transformPlotlyToApex(plotlyData, isDark);
      
      if ((container as any)._chart_instance) {
        (container as any)._chart_instance.destroy();
      }

      const chart = new ApexCharts(container, options);
      chart.render();
      (container as any)._chart_instance = chart;

      setupControls(wrapper, chart, plotlyData);
    } catch (err) {
      console.error(`ApexChart Rendering Error [${container.id}]:`, err);
    }
  }

  function setupControls(wrapper: HTMLElement, chart: ApexCharts, plotlyData: any) {
    const controlsContainer = wrapper.querySelector('.chart-controls');
    if (!controlsContainer || !plotlyData.layout?.updatemenus) return;

    controlsContainer.innerHTML = '';
    const menus = plotlyData.layout.updatemenus;

    menus.forEach((menu: any) => {
      if (menu.buttons) {
        menu.buttons.forEach((btn: any, idx: number) => {
          const button = document.createElement('button');
          button.textContent = btn.label;
          button.className = `px-3 py-1 text-sm font-medium rounded-md border transition-colors ${
            idx === 0 
              ? 'bg-skin-accent text-white border-skin-accent' 
              : 'bg-skin-fill text-skin-base border-skin-line hover:border-skin-accent'
          }`;
          
          button.onclick = () => {
            controlsContainer.querySelectorAll('button').forEach(b => {
              b.classList.remove('bg-skin-accent', 'text-white', 'border-skin-accent');
              b.classList.add('bg-skin-fill', 'text-skin-base', 'border-skin-line');
            });
            button.classList.remove('bg-skin-fill', 'text-skin-base', 'border-skin-line');
            button.classList.add('bg-skin-accent', 'text-white', 'border-skin-accent');

            if (btn.args && btn.args[0] && btn.args[0].visible) {
              const visibleArr = btn.args[0].visible;
              visibleArr.forEach((isVisible: boolean, sIdx: number) => {
                const anyChart = chart as any;
                if (anyChart.w.config.series[sIdx]) {
                  const seriesName = anyChart.w.config.series[sIdx].name;
                  if (isVisible) chart.showSeries(seriesName);
                  else chart.hideSeries(seriesName);
                }
              });
            }
          };
          
          controlsContainer.appendChild(button);
        });
      }
    });
  }

  function transformPlotlyToApex(plotlyData: any, isDark: boolean) {
    const data = plotlyData.data || [];
    const layout = plotlyData.layout || {};
    const isScatter = data.some((d: any) => d.type === 'scatter' && d.mode === 'markers');
    
    const seenNamesLegend = new Set<string>();
    const uniqueColors: string[] = [];
    const series = data.map((d: any) => {
      let color = d.marker?.color || d.line?.color;
      if (Array.isArray(color)) color = color[0];
      const finalColor = color || (isDark ? '#ff6b01' : '#006cac');

      const name = d.name || '';
      if (!seenNamesLegend.has(name)) {
        seenNamesLegend.add(name);
        uniqueColors.push(finalColor);
      }
      
      const s: any = {
        name: name,
        type: (d.type === 'scatter' && d.mode === 'markers') ? 'scatter' : (d.type === 'bar' ? 'bar' : 'line'),
        data: d.y || [],
        yaxisIndex: d.yaxis === 'y2' ? 1 : 0
      };

      if (name.includes('負債') || name.includes('純資産')) {
        s.group = 'liabilities';
      } else if (name.includes('資産')) {
        s.group = 'assets';
      }

      return s;
    });

    const categories = data.length > 0 ? (data[0].x || []) : [];

    // 軸名とインデックスの特定
    const primarySeriesName = series.length > 0 ? series[0].name : 'primary';
    const secondaryIdx = data.findIndex((d: any) => d.yaxis === 'y2');
    const secondarySeriesName = secondaryIdx !== -1 ? series[secondaryIdx].name : null;

    // Y軸設定: 重要：シリーズの数と同じ数だけyaxis設定が必要
    const yaxisConfig = series.map((s: any, idx: number) => {
      const isSecondary = s.yaxisIndex === 1;
      const isFirstOfAxis = isSecondary ? idx === secondaryIdx : idx === 0;

      return {
        seriesName: isSecondary ? secondarySeriesName : primarySeriesName,
        show: isFirstOfAxis,
        opposite: isSecondary,
        min: isSecondary ? 0 : undefined,
        title: { text: isFirstOfAxis ? (isSecondary ? layout.yaxis2?.title?.text : layout.yaxis?.title?.text) : undefined },
        labels: {
          formatter: (val: number) => {
            if (val === null || val === undefined) return '';
            if (isSecondary) return (val * 100).toFixed(0) + '%';
            const absVal = Math.abs(val);
            if (absVal >= 1e12) return (val / 1e12).toFixed(1) + 'T';
            if (absVal >= 1e9) return (val / 1e9).toFixed(1) + 'B';
            if (absVal >= 1e6) return (val / 1e6).toFixed(1) + 'M';
            return val.toLocaleString();
          }
        }
      };
    });

    // ラベルを表示するシリーズ
    const enabledLabelIndices = series
      .map((s: any, idx: number) => (s.yaxisIndex === 0 && !isScatter) ? idx : -1)
      .filter((idx: number) => idx !== -1);

    let options: any = {
      series: series,
      colors: uniqueColors,
      chart: {
        height: '100%',
        type: isScatter ? 'scatter' : (series.length > 0 ? series[0].type : 'line'),
        stacked: layout.barmode !== 'group' && !isScatter,
        toolbar: { show: false },
        background: 'transparent',
        foreColor: isDark ? '#9ca3af' : '#4b5563',
        fontFamily: 'inherit',
        animations: { enabled: true, easing: 'easeinout', speed: 800 }
      },
      theme: { mode: isDark ? 'dark' : 'light' },
      dataLabels: {
        enabled: enabledLabelIndices.length > 0,
        enabledOnSeries: enabledLabelIndices,
        formatter: (val: number) => {
          if (val === null || val === undefined || val === 0) return '';
          const absVal = Math.abs(val);
          if (absVal >= 1e12) return (val / 1e12).toFixed(1) + 'T';
          if (absVal >= 1e9) return (val / 1e9).toFixed(1) + 'B';
          if (absVal >= 1e6) return (val / 1e6).toFixed(1) + 'M';
          if (absVal >= 1e3) return (val / 1e3).toFixed(0) + 'K';
          return val.toFixed(2);
        },
        style: { fontSize: '10px', colors: [isDark ? '#f3f4f6' : '#374151'] },
        dropShadow: { enabled: false }
      },
      stroke: {
        width: series.map((s: any) => s.type === 'line' ? 3 : 0),
        curve: 'smooth'
      },
      markers: {
        size: series.map((s: any) => s.type === 'line' ? 4 : 0),
        strokeWidth: 2,
        hover: { size: 6 }
      },
      xaxis: {
        categories: isScatter ? [] : categories,
        type: isScatter ? 'numeric' : 'category',
        labels: { rotate: 0 }
      },
      yaxis: yaxisConfig,
      grid: {
        borderColor: isDark ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)',
        strokeDashArray: 4
      },
      tooltip: {
        theme: isDark ? 'dark' : 'light',
        shared: !isScatter,
        intersect: isScatter,
        y: { formatter: (val: number) => (val !== null && val !== undefined) ? val.toLocaleString() : '0' }
      },
      legend: {
        position: 'top',
        horizontalAlign: 'center',
        fontSize: '13px',
        itemMargin: { horizontal: 10, vertical: 5 },
        customLegendItems: Array.from(seenNamesLegend),
        onItemClick: { toggleDataSeries: true }
      }
    };

    // Scatter (リスク・リターン) 専用
    if (isScatter) {
      options.series = data.map((d: any) => ({
        name: d.name || '',
        type: 'scatter',
        data: (d.x || []).map((xVal: any, i: number) => [xVal, d.y[i]])
      }));
      options.xaxis.labels = { formatter: (val: any) => (parseFloat(val) * 100).toFixed(1) + '%' };
      
      // 散布図は1軸設定でOK
      options.yaxis = [{
        title: { text: layout.yaxis?.title?.text },
        labels: { formatter: (val: any) => (parseFloat(val) * 100).toFixed(1) + '%' },
        tickAmount: 6
      }];

      const markerShapes = data.map((d: any) => {
        const name = d.name || '';
        if (name === 'S&P 500') return 'square';
        if (name.includes('セクター')) return 'diamond';
        return 'circle';
      });

      const markerSizes = data.map((d: any, idx: number) => {
        if (idx === 3) return 10; 
        if (d.name?.includes('S&P 500') || d.name?.includes('セクター')) return 8;
        return 4;
      });

      options.markers = { size: markerSizes, shape: markerShapes };
      options.colors = data.map((d: any, idx: number) => {
        if (idx === 3) return '#ef4444';
        if (d.name === 'S&P 500') return '#22c55e';
        if (d.name?.includes('セクター')) return '#3b82f6';
        return '#94a3b8';
      });
      
      options.tooltip.x = { show: true, formatter: (val: any) => 'リスク: ' + (parseFloat(val) * 100).toFixed(2) + '%' };
      options.tooltip.y = { formatter: (val: any) => 'リターン: ' + (parseFloat(val) * 100).toFixed(2) + '%' };
    }

    return options;
  }

  document.addEventListener('astro:page-load', () => {
    initApexCharts();
  });

  const themeObserver = new MutationObserver(() => {
    document.querySelectorAll('.apex-graph-div').forEach(container => {
      const wrapper = container.closest('.apex-chart-wrapper') as HTMLElement;
      if (wrapper && (container as any)._apex_initialized) {
        const chartData = JSON.parse(wrapper.dataset.chart || '{}');
        renderApexChart(wrapper, container as HTMLElement, chartData);
      }
    });
  });
  themeObserver.observe(document.documentElement, { attributes: true });

</script>

<style>
  .apex-graph-div {
    width: 100%;
  }
</style>
