---
interface Props {
  chartData: any;
  title?: string;
  id: string;
  height?: number;
}

const { chartData, title, id, height = 450 } = Astro.props;
---

<div 
  class="apex-chart-wrapper my-16" 
  data-chart={JSON.stringify(chartData)}
  data-symbol={chartData.symbol}
>
  {title && <h3 class="text-xl font-bold mb-8">{title}</h3>}
  <div class="chart-controls flex justify-center gap-2 mb-8"></div>
  <div id={id} class="apex-graph-div" style={`height: ${height}px;`}></div>
</div>

<script>
  import ApexCharts from 'apexcharts';

  function initApexCharts() {
    document.querySelectorAll('.apex-graph-div').forEach(container => {
      if ((container as any)._apex_initialized) return;
      const wrapper = container.closest('.apex-chart-wrapper') as HTMLElement;
      if (!wrapper) return;
      const chartData = JSON.parse(wrapper.dataset.chart || '{}');
      renderApexChart(wrapper, container as HTMLElement, chartData);
      (container as any)._apex_initialized = true;
    });
  }

  function renderApexChart(wrapper: HTMLElement, container: HTMLElement, plotlyData: any) {
    if (!plotlyData || !plotlyData.data) return;
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
    const options = transformPlotlyToApex(plotlyData, isDark);
    if (!options) return;

    if ((container as any)._chart_instance) (container as any)._chart_instance.destroy();
    const chart = new ApexCharts(container, options);
    (container as any)._chart_instance = chart;
    chart.render().then(() => setupControls(wrapper, chart, plotlyData));
  }

  // Y軸の単位変換（T, B, M, %）
  function formatYValue(v: any, isPercent: boolean) {
    if (v === null || v === undefined) return '';
    if (isPercent) return (parseFloat(v) * 100).toFixed(0) + '%';
    const absV = Math.abs(v);
    if (absV >= 1e12) return (v / 1e12).toFixed(1) + 'T';
    if (absV >= 1e9) return (v / 1e9).toFixed(1) + 'B';
    if (absV >= 1e6) return (v / 1e6).toFixed(1) + 'M';
    return v.toLocaleString();
  }

  function setupControls(wrapper: HTMLElement, chart: ApexCharts, plotlyData: any) {
    const controlsContainer = wrapper.querySelector('.chart-controls');
    if (!controlsContainer || !plotlyData.layout?.updatemenus) return;
    controlsContainer.innerHTML = '';
    const fullSeries = (chart as any).w.config._fullSeries || [];
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark';

    plotlyData.layout.updatemenus[0].buttons.forEach((btn: any, btnIdx: number) => {
      const button = document.createElement('button');
      button.textContent = btn.label;
      button.className = `px-4 py-1.5 text-sm font-medium rounded-md border transition-colors ${btnIdx === 0 ? 'bg-skin-accent text-white border-skin-accent' : 'bg-skin-fill text-skin-base border-skin-line hover:border-skin-accent'}`;
      
      button.onclick = () => {
        controlsContainer.querySelectorAll('button').forEach(b => {
          b.classList.remove('bg-skin-accent', 'text-white', 'border-skin-accent');
          b.classList.add('bg-skin-fill', 'text-skin-base', 'border-skin-line');
        });
        button.classList.add('bg-skin-accent', 'text-white', 'border-skin-accent');

        if (btn.args && btn.args[0] && btn.args[0].visible) {
          const visMask = btn.args[0].visible;
          const filtered = fullSeries.filter((s: any) => visMask[s.originalIndex] === true);
          const isScatter = filtered.some((s:any) => s.type === 'scatter');
          
          // X軸カテゴリの更新
          let cats = [];
          if (!isScatter && filtered.length > 0) {
            cats = plotlyData.data[filtered[0].originalIndex]?.x || [];
          }

          chart.updateOptions({
            series: filtered,
            colors: filtered.map((s: any) => s.color),
            xaxis: isScatter ? { type: 'numeric', categories: [] } : { categories: cats, type: 'category' },
            yaxis: filtered.map((s: any, i: number) => {
              const is2 = s.yaxisIndex === 1;
              const first0 = filtered.findIndex((fs:any) => fs.yaxisIndex === 0);
              const first1 = filtered.findIndex((fs:any) => fs.yaxisIndex === 1);
              return {
                seriesName: is2 ? (first1 !== -1 ? filtered[first1].name : s.name) : (first0 !== -1 ? filtered[first0].name : s.name),
                show: i === first0 || i === first1,
                opposite: is2,
                labels: { formatter: (v: any) => formatYValue(v, is2 || isScatter), style: { colors: isDark ? '#9ca3af' : '#6b7280' } }
              };
            })
          }, false, true);
        }
      };
      controlsContainer.appendChild(button);
    });
  }

  function transformPlotlyToApex(plotlyData: any, isDark: boolean) {
    const data = plotlyData.data || [];
    const layout = plotlyData.layout || {};
    const isScatterChart = data.some((d: any) => d.type === 'scatter' && d.mode === 'markers');
    
    // 全シリーズの変換
    const allSeries = data.map((d: any, idx: number) => {
      const name = d.name || '';
      const isRatio = name.includes('率') || name.includes('性向');
      const type = isScatterChart ? 'scatter' : (isRatio ? 'line' : (d.type === 'bar' ? 'bar' : 'line'));
      
      const s: any = {
        name: name,
        type: type,
        data: isScatterChart ? (d.x || []).map((xv:any, i:number)=>({x:xv, y:d.y[i], symbol:d.text?d.text[i]:''})) : (d.y || []),
        yaxisIndex: isRatio ? 1 : (d.yaxis === 'y2' ? 1 : 0),
        color: d.marker?.color || d.line?.color || (isDark ? '#ff6b01' : '#006cac'),
        originalIndex: idx,
        originalOrder: 0
      };

      // 積み上げ用順序
      if (name.includes('流動')) s.originalOrder = 1;
      else if (name.includes('固定')) s.originalOrder = 2;
      else if (name.includes('純資産')) s.originalOrder = 3;
      else if (name.includes('配当')) s.originalOrder = 1;
      else if (name.includes('自社株')) s.originalOrder = 2;
// グループ割り当て (積み上げと並列を制御)
if (name.includes('流動資産') || name.includes('固定資産')) s.group = 'assets';
else if (name.includes('負債') || name.includes('純資産')) s.group = 'liabilities';
else if (name.includes('配当') || name.includes('自社株')) s.group = 'payout';
else if (name.includes('純利益')) s.group = 'net_income';
else if (s.type === 'bar') {
  // それ以外の棒グラフ（売上高、営業利益、各キャッシュフロー項目など）は
  // シリーズ名をグループ名にすることで、独立した棒（並列表示）にする
  s.group = name.replace(' (Q)', ''); 
}

return s;
});

// 積み上げ判定: 棒グラフがあれば基本Stackedを有効にする（グループ名で並列/積み上げを制御するため）
const hasBar = allSeries.some(s => s.type === 'bar');
const hasStacking = hasBar && !isScatterChart;
    // シリーズの並び替えロジック
    if (hasStacking) {
      allSeries.sort((a: any, b: any) => {
        // グループ間の並び順を詳細に定義
        const groupPriority: any = { 
          'net_income': 5,  // 純利益を最優先（左端）にする
          '売上高': 10, '売上総利益': 20, '営業利益': 30,
          '営業CF': 10, '投資CF': 20, '財務CF': 30, 'フリーCF': 40,
          'assets': 10, 
          'payout': 60,
          'liabilities': 60
        };
        const pA = groupPriority[a.group] || 99;
        const pB = groupPriority[b.group] || 99;
        
        if (pA !== pB) return pA - pB;
        
        // 2. 同一グループ内での積み上げ順 (originalOrder)
        if (a.group === b.group) return b.originalOrder - a.originalOrder;
        
        return 0;
      });
    }

    const initial = allSeries.filter((s) => data[s.originalIndex]?.visible !== false);
    if (initial.length === 0) return null;

    const cats = !isScatterChart ? (data[initial[0].originalIndex]?.x || []) : [];

    return {
      series: initial,
      colors: initial.map(s => s.color),
      _fullSeries: allSeries,
      chart: {
        height: '100%',
        type: isScatterChart ? 'scatter' : 'line',
        stacked: hasStacking && !isScatterChart,
        stackType: 'normal',
        toolbar: { show: false },
        background: 'transparent',
        foreColor: isDark ? '#9ca3af' : '#6b7280',
        animations: { enabled: true }
      },
      theme: { mode: isDark ? 'dark' : 'light' },
      xaxis: {
        categories: isScatterChart ? undefined : cats,
        type: isScatterChart ? 'numeric' : 'category',
        axisBorder: { show: false },
        min: isScatterChart ? 0 : undefined,
        labels: { formatter: isScatterChart ? (v:any)=>(parseFloat(v)*100).toFixed(0)+'%' : undefined }
      },
      yaxis: initial.map((s: any, i: number) => {
        const is2 = s.yaxisIndex === 1;
        const f0 = initial.findIndex(fs => fs.yaxisIndex === 0);
        const f1 = initial.findIndex(fs => fs.yaxisIndex === 1);
        return {
          seriesName: is2 ? (f1 !== -1 ? initial[f1].name : s.name) : (f0 !== -1 ? initial[f0].name : s.name),
          show: i === f0 || i === f1,
          opposite: is2,
          title: { text: i === f0 ? (layout.yaxis?.title?.text || '') : (i === f1 ? (layout.yaxis2?.title?.text || '') : '') },
          labels: { formatter: (v: any) => formatYValue(v, is2 || isScatterChart) }
        };
      }),
      grid: { borderColor: isDark ? 'rgba(255, 255, 255, 0.05)' : 'rgba(0, 0, 0, 0.05)', strokeDashArray: 4, padding: { top: 20, right: 20, bottom: 10, left: 20 } },
      stroke: { width: initial.map(s => s.type === 'line' ? 3 : (s.type === 'scatter' ? 1 : 0)), curve: 'smooth' },
      markers: { 
        size: initial.map(s => s.type === 'line' ? 4 : (s.type === 'scatter' ? (s.name.includes('対象')?10:6) : 0)),
        strokeWidth: initial.map(s => (s.type === 'scatter' && !s.name.toLowerCase().includes('銘柄') && !s.name.toLowerCase().includes('s&p 500') && !s.name.toLowerCase().includes('セクター')) ? 0 : 2),
        strokeColors: '#fff'
      },
      fill: { opacity: initial.map(s => s.type === 'scatter' ? 0.8 : 1) },
      tooltip: {
        shared: !isScatterChart,
        custom: isScatterChart ? ({ seriesIndex, dataPointIndex, w }: any) => {
          const s = w.config.series[seriesIndex]; const p = s.data[dataPointIndex];
          return `<div class="p-2 bg-skin-fill border border-skin-line rounded shadow-lg text-skin-base"><div class="font-bold border-b border-skin-line mb-1">${p.symbol || s.name}</div><div>リスク: ${(p.x * 100).toFixed(1)}%</div><div>リターン: ${(p.y * 100).toFixed(1)}%</div></div>`;
        } : undefined,
        y: { formatter: (v: any, { seriesIndex, w }: any) => {
          const s = w.config.series[seriesIndex];
          return formatYValue(v, s?.yaxisIndex === 1);
        }}
      },
      legend: { position: 'top', offsetY: -10, customLegendItems: Array.from(new Set(initial.map(s => s.name))) }
    };
  }

  document.addEventListener('astro:page-load', initApexCharts);
  const themeObserver = new MutationObserver(initApexCharts);
  themeObserver.observe(document.documentElement, { attributes: true });
</script>

<style>
  .apex-graph-div { width: 100%; }
  .apex-chart-wrapper {
    background: rgba(var(--color-fill), 0.05);
    border-radius: 0.75rem;
    padding: 1.5rem;
    border: 1px solid rgba(var(--color-line), 0.1);
  }
</style>
